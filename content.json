{"meta":{"title":"Lisme Blog","subtitle":"The day will not come again","description":"励志做个浪漫的Geek","author":"Lisme","url":"http://mysticpg.com"},"pages":[{"title":"about","date":"2017-10-30T02:48:42.000Z","updated":"2017-10-30T02:51:13.038Z","comments":true,"path":"about/index.html","permalink":"http://mysticpg.com/about/index.html","excerpt":"","text":"关于我年轻无为，卖马为生 From Lisme Email: lisme421@qq.com"},{"title":"categories","date":"2017-10-30T02:44:11.000Z","updated":"2017-10-30T02:45:03.995Z","comments":true,"path":"categories/index.html","permalink":"http://mysticpg.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-30T00:51:41.000Z","updated":"2017-10-30T00:52:58.636Z","comments":true,"path":"tags/index.html","permalink":"http://mysticpg.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"new","slug":"new","date":"2017-10-30T10:32:55.000Z","updated":"2017-10-30T12:21:12.957Z","comments":true,"path":"2017/10/30/new/","link":"","permalink":"http://mysticpg.com/2017/10/30/new/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-30T09:54:07.000Z","updated":"2017-10-30T12:19:23.677Z","comments":true,"path":"2017/10/30/hello-world/","link":"","permalink":"http://mysticpg.com/2017/10/30/hello-world/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博文更新","slug":"博文更新","permalink":"http://mysticpg.com/categories/博文更新/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://mysticpg.com/tags/技巧/"}]},{"title":"快速配置zsh","slug":"2017-06-19-快速配置zsh","date":"2017-06-18T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/06/19/2017-06-19-快速配置zsh/","link":"","permalink":"http://mysticpg.com/2017/06/19/2017-06-19-快速配置zsh/","excerpt":"","text":"比较水的 Personal Notes 查看你的系统有几种shellcat /etc/shells 显示 /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 安装 oh my zshgit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 重新打开终端，输入 zsh 即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了 修改主题open ~/.zshrc 修改 ZSH_THEME=”robbyrussell”，主题在 ~/.oh-my-zsh/themes 目录下。修改为 ZSH_THEME=&quot;kolo&quot; 可以参照这里进行选择. 设置为默认shellchsh -s /bin/zsh 添加自定义命令open ~/.zshrc 添加显示隐藏文件的快捷命令 alias fd=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder&apos; alias fh=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder&apos;","categories":[],"tags":[{"name":"终端","slug":"终端","permalink":"http://mysticpg.com/tags/终端/"},{"name":"zsh","slug":"zsh","permalink":"http://mysticpg.com/tags/zsh/"},{"name":"Notes","slug":"Notes","permalink":"http://mysticpg.com/tags/Notes/"}]},{"title":"在 Swift 中使用 IBInspectable","slug":"2017-05-05-在-Swift-中使用-IBInspectable","date":"2017-05-04T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/05/05/2017-05-05-在-Swift-中使用-IBInspectable/","link":"","permalink":"http://mysticpg.com/2017/05/05/2017-05-05-在-Swift-中使用-IBInspectable/","excerpt":"","text":"本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 前言通过 IB 设置 控件 的属性非常的方便。 但是缺点也很明显，那就是有一些属性没有暴露在 IB 的设置面板中。这时候就要使用 @IBInspectable 在 IB 面板中添加这些没有的属性。 关于在 OC 中使用 IBInspectable 可以看一下我的 这篇文章 正文在项目中最常遇到的情况是为 view 设置圆角、描边，以及为 文本控件 添加本地化字符串。 圆角、描边先来看看设置圆角、描边 12345678910111213141516171819202122232425262728293031extension UIView &#123; @IBInspectable var cornerRadius: CGFloat &#123; get &#123; return layer.cornerRadius &#125; set &#123; layer.cornerRadius = newValue layer.masksToBounds = newValue &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat &#123; get &#123; return layer.borderWidth &#125; set &#123; layer.borderWidth = newValue &gt; 0 ? newValue : 0 &#125; &#125; @IBInspectable var borderColor: UIColor &#123; get &#123; return UIColor(cgColor: layer.borderColor!) &#125; set &#123; layer.borderColor = newValue.cgColor &#125; &#125; &#125; 添加完成就可以在 IB 中设置 view 的这些属性了 运行效果 利用 @IBDesignable 在 IB 中实时显示 @IBInspectable 的样式创建一个新的 class 继承 UIView ，并且使用 @IBDesignable 声明 12345import UIKit@IBDesignable class IBDesignableView: UIView &#123;&#125; 在 IB 中，选择 view 的 class 为 我们新建的 IBDesignableView 这样在 IB 调整属性时，这些属性的变化就会实时显示在 IB 中。 本地化字符串本地化字符串的解决方法和上面的添加圆角一样 1234567891011121314151617181920212223242526272829extension UILabel &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; text = NSLocalizedString(newValue, comment: \"\") &#125; get &#123; return text &#125; &#125;&#125;extension UIButton &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; setTitle(NSLocalizedString(newValue, comment: \"\"), for: .normal) &#125; get &#123; return titleLabel?.text &#125; &#125;&#125;extension UITextField &#123; @IBInspectable var localizedKey: String? &#123; set &#123; guard let newValue = newValue else &#123; return &#125; placeholder = NSLocalizedString(newValue, comment: \"\") &#125; get &#123; return placeholder &#125; &#125;&#125; 这样，在 IB 中我们就可以利用对应类型的 Localized Key 来直接设置本地化字符串了： 结语IBInspectable 可以使用这些的类型 Int CGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 合理的使用@IBInspectable 能减少很多的模板代码，提高我们的开发效率。 参考 《再看关于 Storyboard 的一些争论》 《@IBDesignable and @IBInspectable in Swift 3》","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://mysticpg.com/tags/Swift/"},{"name":"IBInspectable","slug":"IBInspectable","permalink":"http://mysticpg.com/tags/IBInspectable/"}]},{"title":"R.swift 的使用","slug":"2017-05-04-R.swift-的使用","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/05/04/2017-05-04-R.swift-的使用/","link":"","permalink":"http://mysticpg.com/2017/05/04/2017-05-04-R.swift-的使用/","excerpt":"","text":"本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 什么是 R.swift介绍 R.swift 前，我们先看看 R.swift 能做什么 通常，我们是基于 字符串 来获取资源，例如：图片、xib、或者是 segue 12let myImage = UIImage(named: \"myImage\")let myViewController = R.storyboard.main.myViewController() 使用 R.swfit，我们可以这样写 12let myImage = R.image.myImage()let viewController = R.storyboard.main.myViewController() R.swift 通过扫描你的各种基于字符串命名的资源，创建一个使用类型来获取资源。 在保证类型安全的同时，也在自动补全的帮助下节省了大量的时间。 导入 R.swiftR.swift 开源在 github 上。 这里是导入的视频教程 使用 CocoaPods 导入项目中 添加 pod &#39;R.swift&#39;到 Podfile 文件，然后运行 pod install 添加一个 New Run Script Phase 将 Run Script 拖动到 Check Pods Manifest.lock 的下面，并且添加脚本 &quot;$PODS_ROOT/R.swift/rswift&quot; &quot;$SRCROOT/项目名称&quot; Command+B 编译项目，在项目代码目录下，会生成一个 R.generated.swift 的文件，将它拖如项目中 注意：不要勾选 Copy items if needed 选项，因为每次编译都会生成新的 R.generated.swift 文件，copy 的话，旧的 R.generated.swift 将不会被覆盖。 tip： 可以在添加 .gitignore 添加一行 *.generated.swift 忽略该文件，避免造成冲突 用法导入完成后，就可以在使用 R.swift 了 关于 R.swift 的更多用法，可以 看这里。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"开源库","slug":"开源库","permalink":"http://mysticpg.com/tags/开源库/"},{"name":"Swift","slug":"Swift","permalink":"http://mysticpg.com/tags/Swift/"}]},{"title":"Swift 的懒加载和计算型属性","slug":"2017-05-03-Swift-的懒加载和计算型属性","date":"2017-05-02T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/05/03/2017-05-03-Swift-的懒加载和计算型属性/","link":"","permalink":"http://mysticpg.com/2017/05/03/2017-05-03-Swift-的懒加载和计算型属性/","excerpt":"","text":"本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接. 懒加载常规（简化）写法 懒加载的属性用 var 声明 123lazy var name: String = &#123; return &quot;BY&quot;&#125;() 完整写法 123lazy var name: String = &#123; () -&gt; String i return &quot;BY&quot;&#125;() 本质是一个创建一个闭包 {} 并且在调用该属性时执行闭包 ()。 如OC的懒加载不同的是 swift 懒加载闭包只调用一次，再次调用该属性时因为属性已经创建，不再执行闭包。 计算型属性常规写法 123var name: string &#123; return &quot;BY&quot;&#125; 完整写法 12345var name: string &#123; get &#123; return &quot;BY&quot; &#125;&#125; 计算型属性本质是重写了 get 方法，其类似一个无参有返回值函数，每次调用该属性都会执行 return 通常这样使用 123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print(&quot;the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)&quot;)// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot; 两者对比相同点 使用方法完全一致 都是用 var 声明 不同点 实现原理不同 懒加载是第一次调用属性时执行闭包进行赋值 计算型属性是重写 get 方法 调用 {}的次数不同 懒加载的闭包只在属性第一次调用时执行 计算型属性每次调用都要进入 {} 中，return 新的值","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://mysticpg.com/tags/Swift/"},{"name":"Swift语法","slug":"Swift语法","permalink":"http://mysticpg.com/tags/Swift语法/"}]},{"title":"RVM 使用指南","slug":"2017-04-28-RVM-使用指南","date":"2017-04-27T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/04/28/2017-04-28-RVM-使用指南/","link":"","permalink":"http://mysticpg.com/2017/04/28/2017-04-28-RVM-使用指南/","excerpt":"","text":"RVM 常用的命令整理 RVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换。https://rvm.io/ 我相信做为iOS开发者，对ruby的使用都是从安装 CocoaPods 开始的吧~ Note：这里所有的命令都是再用户权限下操作的，任何命令最好都不要用 sudo. RVM 安装$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 $ \\curl -sSL https://get.rvm.io | bash -s stable $ source ~/.bashrc $ source ~/.bash_profile 修改 RVM 的 Ruby 安装源到 Ruby China 的 Ruby 镜像服务器，这样能提高安装速度 $ echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db Ruby版本的安装与切换列出已知的 Ruby 版本 rvm list known 安装一个 Ruby 版本 rvm install 2.2.0 --disable-binary 切换 Ruby 版本 rvm use 2.2.0 如果想设置为默认版本，这样一来以后新打开的控制台默认的 Ruby 就是这个版本 rvm use 2.2.0 --default 查询已经安装的ruby rvm list 卸载一个已安装版本 rvm remove 1.8.7 参考：https://ruby-china.org/wiki/rvm-guide","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"ruby","slug":"ruby","permalink":"http://mysticpg.com/tags/ruby/"},{"name":"shell","slug":"shell","permalink":"http://mysticpg.com/tags/shell/"},{"name":"RVM","slug":"RVM","permalink":"http://mysticpg.com/tags/RVM/"}]},{"title":"iOS自动打包","slug":"2017-04-20-iOS自动打包","date":"2017-04-19T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/04/20/2017-04-20-iOS自动打包/","link":"","permalink":"http://mysticpg.com/2017/04/20/2017-04-20-iOS自动打包/","excerpt":"","text":"利用xcode的命令行工具 xcdeobulid 进行项目的编译打包，生成ipa包，并上传到fir 前言现在网上的自动打包教程几乎都还是xcodebuild + xcrun的方式先生成.app包 再生成.ipa包,结果弄了一整天硬是没成功~ 后来发现PackageApplication is deprecated，悲剧。然后手动压缩的 .ipa包因为签名问题无法装到手机上。 后来用了archive + -exportArchive终于可以了~ 正文Xcodebuildxcodebuild 的使用可以用 man xcodebuild查看。 查看项目详情 # cd 项目主目录 xcodebuild -list 输出项目的信息 Information about project &quot;StackGameSceneKit&quot;: Targets: StackGameSceneKit StackGameSceneKitTests Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used. Schemes: StackGameSceneKit 要留意 Configurations，Schemes这两个属性。 自动打包流程生成 archive生成archive的命令是 xcodebuild archive xcodebuild archive -workspace ${project_name}.xcworkspace \\ -scheme ${scheme_name} \\ -configuration ${build_configuration} \\ -archivePath ${export_archive_path} 参数一：项目类型，，如果是混合项目 workspace 就用 -workspace，如果是 project 就用 -project -scheme：项目名，上面xcodebuild -list中的 Schemes -configuration：编译类型，在configuration选择, Debug 或者 Release -archivePath：生成 archive 包的路径，需要精确到 xx/xx.archive 首先需要创建一个AdHocExportOptions.plist文件 导出ipa包导出.ipa包经常会出现错误，在ruby2.4.0版本中会报错，所以请使用其他版本的ruby,最初的原因是使用了 ruby2.4.0 进行编译时出现的错误。 解决方法是低版本的 ruby 进行编译，如使用系统版本：rvm use system。后面升级macOS系统（10.12.5）后发现 ruby2.4.0 能成功 导出ipa包了。 导出ipa包使用命令：xcodebuild -exportArchive xcodebuild -exportArchive \\ -archivePath ${export_archive_path} \\ -exportPath ${export_ipa_path} \\ -exportOptionsPlist ${ExportOptionsPlistPath} archivePath：上面生成 archive 的路径 -exportPath：导出 ipa包 的路径 exportOptionsPlist：导出 ipa包 类型，需要指定格式的plist文件，分别是AppStroe、AdHoc、Enterprise,如下图 选择这三个类别需要分别创建三个plist文件： AdHocExportOptionsPlist.plist AppStoreExportOptionsPlist.plist EnterpriseExportOptionsPlist.plist 上传到 Fir将项目上传到 Fir 下载 fir 命令行工具 gem install fir-cli 获取 fir 的 API Token（右上角） 上传 fir publish &quot;ipa_Path&quot; -T &quot;firApiToken&quot; 自动打包脚本再次提醒，请不要使用 ruby 2.4.0 运行该脚本！，若在 ruby 2.4.0 下编译失败，请切换低版本的ruby。 切换完毕记得重新安装 fir 命令行工具。 脚本我fork了 jkpang 的脚本进行修改，添加了自动上传到 fir 的功能。 使用方法在Github上有详细介绍。 GitHub：https://github.com/qiubaiying/iOSAutoArchiveScript 利用 自定义终端指令 简化打包过程以zsh为例: open ~/.zshrc 添加自定义命令 cd + sh alias mybuild=&apos;cd 项目地址/iOSAutoArchiveScript/ &amp;&amp; sh 项目地址/iOSAutoArchiveScript/iOSAutoArchiveScript.sh&apos; 这样打开终端输入mybuild，就可以轻松实现一键打包上传了 本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://mysticpg.com/tags/Xcode/"},{"name":"ruby","slug":"ruby","permalink":"http://mysticpg.com/tags/ruby/"},{"name":"shell","slug":"shell","permalink":"http://mysticpg.com/tags/shell/"}]},{"title":"CocoaPods 安装和使用","slug":"2017-04-13-CocoaPods-安装和使用","date":"2017-04-12T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/04/13/2017-04-13-CocoaPods-安装和使用/","link":"","permalink":"http://mysticpg.com/2017/04/13/2017-04-13-CocoaPods-安装和使用/","excerpt":"","text":"前言最近换了新机器，重新搭建了开发环境，其中当然包括 CocoaPods。 装完顺便更新下 CocoaPods 安装文档。 正文安装CocoaPods 是用 ruby 实现的，要想使用它首先需要有 ruby 的环境。 升级ruby查看ruby版本 $ ruby -v ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin16] CocoaPods需要2.2.2版本及以上的，我们先升级ruby。 使用 rvm 安装 ruby curl -L get.rvm.io | bash -s stable source ~/.bashrc source ~/.bash_profile 切换 ruby 源 ruby 下载源使用亚马逊的云服务被墙了，切换国内的 ruby-china源 （https://ruby.taobao.org/已经停止维护，详情查看公告）： $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ $ gem sources -l *** CURRENT SOURCES *** https://gems.ruby-china.org 安装并切换 ruby 这里不建议安装最新的 2.4.0 版本，因为次版本的 ruby，在xcodebuild 自动打包时，会出现问题！ 所以退一步，安装 2.3.3版本~ rvm install 2.3.3 --disable-binary rvm use 2.3.3 --default 到此ruby升级完毕. 有关RVM的使用可以看这篇 RVM 使用指南 安装CocoaPods 安装 sudo gem install -n /usr/local/bin cocoapods 升级版本库 pod setup 这里需要下载版本库（非常庞大），需要等很久 Receiving objects: 72% (865815/1197150), 150.07 MiB | 190.00 KiB/s 或者直接从其他装有cocoapod的电脑中拷贝~/.cocoapods到你的用户目录，然后再 pod setup会节省不少时间 使用创建 podfile 文件绝大多数人创建podfile都是用 vim Podfile 命令 其实pod 已经提供了创建 podfile 文件的命令，在工程目录下 pod init 将会自动生成 podfile 文件，并且为你写好了格式，稍做修改就能使用 1234567891011121314151617181920# Uncomment the next line to define a global platform for your project# platform :ios, &apos;9.0&apos;target &apos;projectName&apos; do # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks use_frameworks! # Pods for projectName target &apos;projectNameTests&apos; do inherit! :search_paths # Pods for testing end target &apos;projectNameUITests&apos; do inherit! :search_paths # Pods for testing endend 其中的 123456789target &apos;projectNameTests&apos; do inherit! :search_paths # Pods for testing end target &apos;projectNameUITests&apos; do inherit! :search_paths # Pods for testing end 是指定在单元测试和UI测试时导入的测试框架，若没有使用测试框架可以删除。 修改iOS版本，添加Alamofire库 123456789101112# Uncomment the next line to define a global platform for your project# platform :ios, &apos;8.0&apos;target &apos;projectName&apos; do # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks use_frameworks! # Pods for projectName pod &apos;Alamofire&apos;, &apos;~&gt; 4.4&apos;end 加载代码库使用下面的命令，直接在本地版本库中查找对应的代码库信息，不升级版本库，节省时间 pod install --verbose --no-repo-update 若找不到库，再使用下面的命令 pod install 版本号对版本号的操作除了指定与不指定，你还可以做其他操作： \\&gt;0.1 高于0.1的任何版本 \\&gt;=0.1 版本0.1和任何更高版本 &lt;0.1 低于0.1的任何版本 &lt;=0.1 版本0.1和任何较低的版本 〜&gt;0.1.2 版本 0.1.2的版本到0.2 ，不包括0.2。这个基于你指定的版本号的最后一个部分。这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本 结语关于CocoaPods的安装和使用就这样简单的介绍完了，至于更多使用的方法（平时也用不到~）你可以用下面命令查看 $ pod 若对 CocoaPods 的个人仓库感兴趣，也可以看看我的这两篇博客 CocoaPods公有仓库的创建 CocoaPods私有仓库的创建 本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://mysticpg.com/tags/Xcode/"},{"name":"Cocopods","slug":"Cocopods","permalink":"http://mysticpg.com/tags/Cocopods/"},{"name":"ruby","slug":"ruby","permalink":"http://mysticpg.com/tags/ruby/"}]},{"title":"强化 swift 中的 print","slug":"2017-04-07-强化-Swift-中的-print","date":"2017-04-06T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/04/07/2017-04-07-强化-Swift-中的-print/","link":"","permalink":"http://mysticpg.com/2017/04/07/2017-04-07-强化-Swift-中的-print/","excerpt":"","text":"在 Swift 中，最简单的输出方法就是使用 print()，在我们关心的地方输出字符串和值。 当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。 在 Swift 中，编译器为我们准备了几个很有用的编译符号，它们分别是： 符号类型描述#fileString包含这个符号的文件的路径#lineInt符号出现处的行号#columnInt符号出现处的列#functionString包含这个符号的方法名字 有了上面的这些编译符号，我们就可以自定义一个输出函数：printm 123public func printm(items: Any..., filename: String = #file, function: String = #function, line: Int = #line) &#123; print(\"[\\((filename as NSString).lastPathComponent) \\(line) \\(function)]\\n\",items)&#125; 因为输出是一个很消耗性能的操作，所以在releass环境下需要将输出函数去掉，将上面的函数换成： 1234567891011#if DEBUGpublic func printm(items: Any..., filename: String = #file, function: String = #function, line: Int = #line) &#123; print(\"[\\((filename as NSString).lastPathComponent) \\(line) \\(function)]\\n\",items)&#125;#elsepublic func printm(items: Any..., filename: String = #file, function: String = #function, line: Int = #line) &#123; &#125;#endif 参考: 《LOG 输出》 - 王巍 (@ONEVCAT) 本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://mysticpg.com/tags/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"http://mysticpg.com/tags/Xcode/"},{"name":"Debug","slug":"Debug","permalink":"http://mysticpg.com/tags/Debug/"}]},{"title":"Swift 3.1 的新变化「译」","slug":"2017-03-30-Swift 3.1-的新变化「译」","date":"2017-03-29T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/30/2017-03-30-Swift 3.1-的新变化「译」/","link":"","permalink":"http://mysticpg.com/2017/03/30/2017-03-30-Swift 3.1-的新变化「译」/","excerpt":"","text":"Xcode 8.3 和 Swift 3.1 现在已经发布了(3/28)！ 可以通过 AppStore 或 Apple Developer 进行下载 Xcode 8.3 优化了 Objective-C 与 Swift 混编项目的编译速度. Swift 3.1 版本包含一些期待已久的 Swift package manager 功能和语法本身的改进。 如果您没有密切关注 Swift Evolution 进程，请继续阅读 - 本文非常适合您！ 在本文中，我将强调Swift 3.1中最重要的变化，这将对您的代码产生重大影响。我们来吧！😃 开始Swift 3.1与Swift 3.0源代码兼容，因此如果您已经使用Xcode 中的 Edit \\ Convert \\ To Current Swift Syntax ... 将项目迁移到Swift 3.0，新功能将不会破坏您的代码。不过，苹果已经在Xcode 8.3中支持Swift 2.3。所以如果你还没有从Swift 2.3迁移，现在是时候这样做了！ 在下面的部分，您会看到链接的标签，如[SE-0001]。这些是 Swift Evolution 提案号码。我已经列出了每个提案的链接，以便您可以发现每个特定更改的完整详细信息。我建议您尝试在Playground上验证新的功能，以便更好地了解所有更改的内容。 Note:如果你想了解 swift 3.0 中的新功能，可以看这篇文章。 语法改进首先，我们来看看这个版本中的语法改进，包括关于数值类型的可失败构造器（Failable Initializers），新的序列函数等等。 可失败的数值转换构造器（Failable Numeric Conversion Initializers）Swift 3.1 为所有数值类型 (Int, Int8, Int16, Int32, Int64, UInt, UInt8, UInt16, UInt32, UInt64, Float, Float80, Double) 添加了可失败构造器。 这个功能非常有用，例如，以安全、可恢复的方式处理外源松散类型数据的转换，下面来看 Student 的 JSON 数组的处理： 12345678910111213141516171819202122232425262728293031class Student &#123; let name: String let grade: Int init?(json: [String: Any]) &#123; guard let name = json[\"name\"] as? String, let gradeString = json[\"grade\"] as? String, let gradeDouble = Double(gradeString), let grade = Int(exactly: gradeDouble) // &lt;-- 3.1 的改动在这 else &#123; return nil &#125; self.name = name self.grade = grade &#125;&#125; func makeStudents(with data: Data) -&gt; [Student] &#123; guard let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments), let jsonArray = json as? [[String: Any]] else &#123; return [] &#125; return jsonArray.flatMap(Student.init)&#125; let rawStudents = \"[&#123;\\\"name\\\":\\\"Ray\\\", \\\"grade\\\":\\\"5.0\\\"&#125;, &#123;\\\"name\\\":\\\"Matt\\\", \\\"grade\\\":\\\"6\\\"&#125;, &#123;\\\"name\\\":\\\"Chris\\\", \\\"grade\\\":\\\"6.33\\\"&#125;, &#123;\\\"name\\\":\\\"Cosmin\\\", \\\"grade\\\":\\\"7\\\"&#125;, &#123;\\\"name\\\":\\\"Steven\\\", \\\"grade\\\":\\\"7.5\\\"&#125;]\"let data = rawStudents.data(using: .utf8)!let students = makeStudents(with: data)dump(students) // [(name: \"Ray\", grade: 5), (name: \"Matt\", grade: 6), (name: \"Cosmin\", grade: 7)] 在 Student 类中使用了一个可失败构造器将 grade 属性从 Double 转变为 Int，像这样 1let grade = Int(exactly: gradeDouble) 如果gradeDouble不是整数，例如6.33，它将失败。如果它可以用一个正确的表示Int，例如6.0，它将成功。 Note：虽然throwing initializers 可以用来替代 failable initializers。但是使用 failable initializers 会更好，更符合人的思维。 新的序列函数（Sequence Functions）swift3.1添加了两个新的标准库函数在 Sequence 协议中：prefix(while:)``和prefix(while:)[SE-0045]。 构造一个斐波纳契无限序列： 12345let fibonacci = sequence(state: (0, 1)) &#123; (state: inout (Int, Int)) -&gt; Int? in defer &#123;state = (state.1, state.0 + state.1)&#125; return state.0&#125; 在Swift 3.0中，您只需指定迭代次数即可遍历fibonacci序列： 1234// Swift 3.0for number in fibonacci.prefix(10) &#123; print(number) // 0 1 1 2 3 5 8 13 21 34&#125; 在swift 3.1中，您可以使用prefix(while:)和drop(while:)获得符合条件在两个给定值之间的序列中的所有元素，就像这样： 12345// Swift 3.1let interval = fibonacci.prefix(while: &#123;$0 &lt; 1000&#125;).drop(while: &#123;$0 &lt; 100&#125;)for element in interval &#123; print(element) // 144 233 377 610 987&#125; prefix(while:)返回满足某个谓词的最长子序列。它从序列的开头开始，并停在给定闭包返回false的第一个元素上。 drop(while:) 相反：它返回从给定关闭返回false的第一个元素开始的子序列，并在序列结尾完成。 Note:这种情况，可以使用尾随闭包的写法： 12&gt; let interval = fibonacci.prefix&#123;$0 &lt; 1000&#125;.drop&#123;$0 &lt; 100&#125;&gt; Concrete Constrained Extensions（姑且翻译为类的约束扩展吧）Swift 3.1允许您扩展具有类型约束的通用类型。以前，你不能像这样扩展类型，因为约束必须是一个协议。我们来看一个例子。 例如，Ruby on Rails提供了一种isBlank检查用户输入的非常有用的方法。以下是在Swift 3.0中用 String 类型的扩展实现这个计算型属性： 123456789101112// Swift 3.0extension String &#123; var isBlank: Bool &#123; return trimmingCharacters(in: .whitespaces).isEmpty &#125;&#125; let abc = \" \"let def = \"x\" abc.isBlank // truedef.isBlank // false 如果你希望isBlank计算型属性为一个可选值所用，在swift 3.0中，你将要这样做 123456789101112131415161718192021222324// Swift 3.0protocol StringProvider &#123; var string: String &#123;get&#125;&#125; extension String: StringProvider &#123; var string: String &#123; return self &#125;&#125; extension Optional where Wrapped: StringProvider &#123; var isBlank: Bool &#123; return self?.string.isBlank ?? true &#125;&#125; let foo: String? = nillet bar: String? = \" \"let baz: String? = \"x\" foo.isBlank // truebar.isBlank // truebaz.isBlank // false 这创建了一个采用 String 的 StringProvider 协议而在你使用StringProvider扩展可选的 wrapped 类型时,添加isBlank方法。 Swift 3.1中，用来替代协议方法，扩展具体类型的方法像这样： 123456// Swift 3.1extension Optional where Wrapped == String &#123; var isBlank: Bool &#123; return self?.isBlank ?? true &#125;&#125; 这就用更少的代码实现了和原先相同的功能~ 泛型嵌套（Nested Generics）Swift 3.1允许您将嵌套类型与泛型混合。作为一个练习，考虑这个（不是太疯狂）的例子。每当某个团队领导raywenderlich.com想在博客上发布一篇文章时，他会分配一批专门的开发人员来处理这个问题，以满足网站的高质量标准： 1234567891011121314151617181920212223242526272829303132333435363738class Team&lt;T&gt; &#123; enum TeamType &#123; case swift case iOS case macOS &#125; class BlogPost&lt;T&gt; &#123; enum BlogPostType &#123; case tutorial case article &#125; let title: T let type: BlogPostType let category: TeamType let publishDate: Date init(title: T, type: BlogPostType, category: TeamType, publishDate: Date) &#123; self.title = title self.type = type self.category = category self.publishDate = publishDate &#125; &#125; let type: TeamType let author: T let teamLead: T let blogPost: BlogPost&lt;T&gt; init(type: TeamType, author: T, teamLead: T, blogPost: BlogPost&lt;T&gt;) &#123; self.type = type self.author = author self.teamLead = teamLead self.blogPost = blogPost &#125;&#125; 将BlogPost内部类嵌套在其对应的Team外部类中，并使两个类都通用。这是团队如何寻找我在网站上发布的教程和文章： 1234567Team(type: .swift, author: \"Cosmin Pupăză\", teamLead: \"Ray Fix\", blogPost: Team.BlogPost(title: \"Pattern Matching\", type: .tutorial, category: .swift, publishDate: Date())) Team(type: .swift, author: \"Cosmin Pupăză\", teamLead: \"Ray Fix\", blogPost: Team.BlogPost(title: \"What's New in Swift 3.1?\", type: .article, category: .swift, publishDate: Date())) 但实际上，在这种情况下，您可以简化该代码。如果嵌套的内部类型使用通用外部类型，那么它默认继承父类的类型。因此，您不需要如此声明： 1234567891011121314class Team&lt;T&gt; &#123; // original code class BlogPost &#123; // original code &#125; // original code let blogPost: BlogPost init(type: TeamType, author: T, teamLead: T, blogPost: BlogPost) &#123; // original code &#125;&#125; Note：如果您想了解更多关于Swift中的泛型，请阅读我们最近更新的Swift泛型入门的教程。 Swift版本的可用性您可以使用#if swift(&gt;= N) 静态构造来检查特定的Swift版本： 12345678910// Swift 3.0#if swift(&gt;=3.1) func intVersion(number: Double) -&gt; Int? &#123; return Int(exactly: number) &#125;#elseif swift(&gt;=3.0) func intVersion(number: Double) -&gt; Int &#123; return Int(number) &#125;#endif 然而，当使用Swift标准库时，这种方法有一个主要缺点。它需要为每个受支持的旧语言版本编译标准库。这是因为当您以向后兼容模式运行Swift编译器时，例如您要使用Swift 3.0行为，则需要使用针对该特定兼容性版本编译的标准库版本。如果您使用版本3.1模式编译的，那么您根本就没有正确的代码 因此，@available除了现有平台版本 [SE-0141] 之外，Swift 3.1扩展了该属性以支持指定Swift版本号： 1234567891011// Swift 3.1 @available(swift 3.1)func intVersion(number: Double) -&gt; Int? &#123; return Int(exactly: number)&#125; @available(swift, introduced: 3.0, obsoleted: 3.1)func intVersion(number: Double) -&gt; Int &#123; return Int(number)&#125; 这个新功能提供了与intVersionSwift版本有关的方法相同的行为。但是，它只允许像标准库这样的库被编译一次。编译器然后简单地选择可用于所选择的给定兼容性版本的功能。 Note：注意：如果您想了解更多关于Swift 的可用性属性（ availability attributes），请参阅我们关于Swift中可用性属性的教程。 逃逸闭包（Escaping Closures）在Swift 3.0 [ SE-0103 ] 中函数中的闭包的参数是默认是不逃逸的（non-escaping）。在Swift 3.1中，您可以使用新的函数withoutActuallyEscaping()将非逃逸闭包转换为临时逃逸。 1234567891011func perform(_ f: () -&gt; Void, simultaneouslyWith g: () -&gt; Void, on queue: DispatchQueue) &#123; withoutActuallyEscaping(f) &#123; escapableF in // 1 withoutActuallyEscaping(g) &#123; escapableG in queue.async(execute: escapableF) // 2 queue.async(execute: escapableG) queue.sync(flags: .barrier) &#123;&#125; // 3 &#125; // 4 &#125;&#125; 此函数同时加载两个闭包，然后在两个完成之后返回。 f 与 g 进入函数后由非逃逸状态，分别转换为逃逸闭包:escapableF和escapableG。 async(execute:) 的调用需要逃逸闭包，我们在上面已经进行了转换。 通过运行sync(flags: .barrier)，您确保async(execute:)方法完全完成，稍后将不会调用闭包。 在范围内使用 escapableF and escapableG. 如果你存储临时逃离闭包(即真正逃脱)这将是一个Bug。未来版本的标准库可以检测这个陷阱,如果你试图调用它们。 Swift Package Manager 更新啊，期待已久的 Swift Package Manage 的更新了！ 可编辑软件包（Editable Packages）Swift 3.1将可编辑软件包(editable packages)的概念添加到Swift软件包管理器 [ SE-0082 ]。 该swift package edit命令使用现有的Packages并将其转换为editable Packages。使用--end-edit命令将 package manager 还原回 规范解析的软件包（canonical resolved packag）。 版本固定（Version Pinning）Swift 3.1 添加了版本固定的概念[ SE-0145 ]。该 pin 命令 固定一个或所有依赖关系如下所示： 123$ swift package pin --all // 固定所有的依赖$ swift package pin Foo // 固定 Foo 在当前的闭包$ swift package pin Foo --version 1.2.3 // 固定 Foo 在 1.2.3 版本 使用unpin命令恢复到以前的包版本： 12$ swift package unpin —all$ swift package unpin Foo Package manager 将每个依赖库的版本固定信息存储在 Package.pins 文件中。如果该文件不存在，则Package manager 会自动创建。 其他swift package reset 命令将会把 Package 重置干净。 swift test --parallel 命令 执行测试。 其他改动在 swift 3.1 中还有一些小改动 多重返回函数C函数返回两次，例如vfork 和 vfork已经不用了。他们以有趣的方式改变了程序的控制流程。所以 Swift 社区 已经禁止了该行为，以免导致编译错误。 自动链接失效（Disable Auto-Linking）Swift Package Manager 禁用了在C语言 模块映射（module maps）中的自动链接的功能： 123456789101112// Swift 3.0module MyCLib &#123; header “foo.h\" link “MyCLib\" export *&#125; // Swift 3.1module MyCLib &#123; header “foo.h” export *&#125; 结语Swift 3.1改善了Swift 3.0的一些功能，为即将到来的Swift 4.0的大改动做准备。这些包括对泛型，正则表达式，更科学的String等方面的作出极大的改进。 如果你想了解更多，请转到 Swift standard library diffs 或者查看官方的的Swift CHANGELOG，您可以在其中阅读所有更改的信息。或者您可以使用它来了解 Swift 4.0 中的内容！ 著作权声明本文译自 What’s New in Swift 3.1? 由@柏荧(BY)进行翻译,首次发布于 BY Blog，转载请保留原文链接.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://mysticpg.com/tags/Swift/"},{"name":"Xcode","slug":"Xcode","permalink":"http://mysticpg.com/tags/Xcode/"}]},{"title":"AsyncDisplayKit 2.0 教程:入门「译」","slug":"2017-03-23-AsyncDisplayKit-2.0-教程：入门「译」","date":"2017-03-22T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/23/2017-03-23-AsyncDisplayKit-2.0-教程：入门「译」/","link":"","permalink":"http://mysticpg.com/2017/03/23/2017-03-23-AsyncDisplayKit-2.0-教程：入门「译」/","excerpt":"","text":"AsyncDisplayKit 2.0 Tutorial: Getting Started 前言 “艺术是你任何能做到极致的事” AsyncDisplayKit 是一个UI框架，最初诞生于 Facebook 的 Paper 应用程序。它是为了解决 Paper 团队面临的核心问题之一：如何尽可能缓解主线程的压力？ 现在,许多应用程序的用户体验,很大程度上依赖于持续手势和物理动画。至少,你的UI可能是依赖于某种形式的 scrollView。 这些类型的用户界面完全依赖于主线程，并且对主线程阻塞非常敏感。主线程阻塞将导致丢帧，降低用户的体验。 一些主线程开销较大的任务包括： 计算尺寸和布局：比如 -heightForRowAtIndexPath:，或者在UILbel中调用 -sizeThatFits 以及指数上升的 AutoLayout‘s布局计算。 图像解码：想要在一个 image view 中使用 UIImage，首先要进行解码。 绘图：复杂的文本以及手动绘制渐变和阴影。 对象生命周期：创建，操纵和销毁系统对象（即创建一个UIView） 当正确使用时,AsyncDisplayKit 允许您在默认情况下异步执行所有测量、布局和渲染。无需任何额外的优化，一个应用程序可以减少约一个数量级的主线程开销。 除了这些性能优势，酷炫的 AsyncDisplayKit 还为开发者提供的便利接口，用简洁的代码就能完成复杂的功能。 在这两部分 AsyncDisplayKit 2.0 教程中，你将掌握使用ASDK构建一个实用的和动态的应用程序的所有要素。在第一部分中，你将要学习一些在你构建应用程序时可以用到的宏观思想。在第二部分中，你将学习如何构建自己 node 的 subclass，以及如何使用ASDK强大的布局引擎。为了更好的完成本教程，你需要会使用 Xcode 以及 熟悉 Objective-C。 免责声明：ASDK不兼容 Interface Builder和AutoLayout，因此，您将不会在本教程中使用它们，虽然ASDK完全支持Swift(除了ComponentKit)，许多开发者仍在使用Objective-C。免费App排行榜前100大多数都没有使用Swift（至少6个使用ASDK）。出于这些原因，本系列将重点介绍 Objective-C。话虽这么说，我们已经包括了一个Swift版本的实例项目。（嘴上说没有，代码还是很诚实的😂~） 开始首先，下载初始项目。 该项目使用 CocoaPods 来拉入AsyncDisplayKit。所以，在正常的 CocoaPods 体系下，打开 RainforestStarter.xcworkspace 而不是RainforestStarter.xcodeproj。 注意：需要网络连接才能完成本教程。 构建并运行以查看包含 UITableView 动物列表的应用程序。如果你看过了代码，AnimalTableController 你会发现这是一个正常且熟悉的 UITableViewController 类。 注意：确保在真机上运行本教程中的代码，而不是在模拟器中运行。 向上滑动你将看到帧数丢失引起的卡顿。你不需要启动控制台，以便能发现到这个应用程序需要在性能方面上的一些优化。 你可以通过 AsyncDisplayKit 的力量来解决这个问题 ASDisplayNode 简介ASDisplayNode 是ASDK的核心类，它只是一个类似于 MVC 中的 “View” 一样的UIView 或 CALayer。认识一个 node 的最佳方法是参照你已经熟悉的 UIViews 和 CALayers 之间的关系。 记住，iOS应用程序中的所有在屏幕上的显示都通过CALayer对象表示的。UIViews 创建并且拥有一个底层的 CALayer，并为他们添加触摸处理和其他交互功能。UIView 并不是 CALayer 的子类，而是相互环绕，扩展其功能。 这种抽象的情况下扩展 ASDisplayNode：您可以将它们视为包装一个 view，就像在 view 上添加一个 layer 一样。 通常由 Node 创建的一个常规的view，其创建和配置都在行队列中执行，并且异步渲染。 幸运的是，用于处理 Node 的 API 对于任何使用过的 UIViews 或者 CALayers 的人来说应该异常的熟悉。所有 View 的属性都可以等效为 Node 类。你可以访问基础的 view 或者 layer 本身，就像是访问 view.layer 一样 节点容器（The Node Containers）虽然 Node 本身提供了巨大的性能改进的可能，但真正的强大的是它们与四个容器类结合使用时产生的黑魔法。 这些类包括： ASViewController：一个 UIViewController 的子类，允许你提供要管理的 Node。 ASCollectionNode and ASTableNode：Node 等效于 UICollectionView 和 UITableView，其子类实际上保留在底层。 ASPagerNode:一个ASCollectionNode的子类，提供极好的滑动性能相比与 UIKit 的 UIPageViewController 来说。 说得好，但真正的黑魔法来自 ASRangeController 这些类用于影响所包含的 Node 的行为。现在，跟着我并把你们的脑袋放空吧~ TableNode你要做的第一件事就是将当前 TableView 替换为 TableNode。这个没什么难度。 将 TableView 替换为 TableNode首先，进入到 AnimalTableController.m 。在此类中添加下面代码下面代码。 #import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt; 这就导入了 ASDK 框架。 然后，我们继续，替换 tableView 的声明属性 ： @property （ strong，nonatomic ） UITableView * tableView; 替换为 tableNode： @property （ strong，nonatomic ） ASTableNode * tableNode; 这将导致这个类中很多地方报错，但不要慌张！ 别担心。这些错误和警告将作为你的向导，将代码转换成我们想要的。 -viewDidLoad 中的报错是理所当然，因为 tableView 已经被替换掉。我不会让你通过 tableNode 替换 所有的 tableView 实例（我的意思是，查找和替换并非那么难），但是如果你做了，你会看到： 你应该为 ASTableNode 分配一个属性。 table Node 没有调用 -registerClass:forCellReuseIdentifier: 方法。 你不能添加一个 node 到 subview 此时，你应该将 -viewDidLoad 中的方法替换为： - (void)viewDidLoad { [super viewDidLoad]; [self.view addSubnode:self.tableNode]; [self applyStyle]; } 这里要注意一个有趣的情况，你调用的是 UIView 的一个 -addSubnode: 方法，该方法是通过 category 添加到 UIView 上的，等效于: [self.view addSubview:self.tableNode.view]; 接下来，修改 -viewWillLayoutSubviews 中的代码： - (void)viewWillLayoutSubviews { [super viewWillLayoutSubviews]; self.tableNode.frame = self.view.bounds; } 这样就替换用 self.tableNode 替换了 self.tableView，并且设置了 table 的 Frame 继续修改 -applyStyle 方法中的代码为： - (void)applyStyle { self.view.backgroundColor = [UIColor blackColor]; self.tableNode.view.separatorStyle = UITableViewCellSeparatorStyleNone; } 这是唯一设置 table 的 separatorStyle 的一行代码。注意 tableNode 的 view 是如何访问 table 的 separatorStyle 属性的。ASTableNode 不会暴露所有UITableView的的属性，所以你必须通过 tableNode 底层的 UITableView 实例去设置 UITableView 的特殊属性。 然后，在 -initWithAnimals: 方法中添加。 _tableNode = [[ASTableNode alloc] initWithStyle:UITableViewStylePlain]; 并且在 return 之前，调用： [self wireDelegation]; 这就会在初始化 AnimalTableController 的时候，创建了一个 tableNode 并且调用 -wireDelegation 方法 设置 tableNode 的 代理。 设置 TableNode 的 DataSource &amp; Delegate类似于 UITableView，ASTableNode 也使用 DataSource 和 Delegate 来设置本身。TableNode 的ASTableDataSource 和 ASTableDelegate protocols 非常类似于 UITableViewDataSource 和 UITableViewDelegate。 事实上，虽然他们定义了一些完全相同的方法，如 -tableNode:numberOfRowsInSection:，但两组协议也不完全相同，因为 ASTableNode 行为和UITableView还以所有不同的。 找到 -wireDelegation 方法， 并用 tableNode 替换 tableView： - (void)wireDelegation { self.tableNode.dataSource = self; self.tableNode.delegate = self; } 现在， 你会收到警告, AnimalTableController 实际上不符合协议。目前，AnimalTableController 仅遵循 UITableViewDataSource 和 UITableViewDelegate协议。在下面的章节中，我们将遵循这些协议，使我们能够使用 tableNode 的功能。 遵循 ASTableDataSource在 AnimalTableController.m 开头的地方找到 AnimalTableController 的 DataSource 扩展声明： 12@interface AnimalTableController (DataSource)&lt;UITableViewDataSource&gt;@end 用 ASTableDataSource 替换 UITableViewDataSource为： @interface AnimalTableController (DataSource)&lt;ASTableDataSource&gt; @end 现在，AnimalTableController 已经遵循了 AnimalTableController 协议。本就该如此了。 导航到 AnimalTableController.m 的底部并找到 DataSource category 的实现。 首先，将 UITableViewDataSource 的 -tableView:numberOfRowsInSection:方法，更改为ASTableDataSource 的版本。 123- (NSInteger)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(NSInteger)section &#123; return self.animals.count;&#125; 接着，ASTableNodes 的 cells 会以不同于 UITableView 的方式返回。用下面的代码替换 -tableView:cellForRowAtIndexPath: 以适应新的规则。 123456789101112131415// 1- (ASCellNodeBlock)tableNode:(ASTableView *)tableView nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 2 RainforestCardInfo *animal = self.animals[indexPath.row]; // 3 return ASCellNodeBlock return ^&#123; // 4 CardNode *cardNode = [[CardNode alloc] initWithAnimal:animal]; //You'll add something extra here later... return cardNode; &#125;;&#125; 让我们整理一下： ASDK 中的 ASCellNode 等价于 UITableViewCell 或者 UICollectionViewCell。要注意的是这个方法返回的是一个 ASCellNodeBlock，ASTableNode 维持着内部所有的 Cell，每个 indexPath 对应一个 block，并且随时准备进行初始化。 你的首要任务是通过数据模型构建cell。这是非常重要的一步，要注意！你获取数据后在 下面的 block 处理。不要在 block 里引用indexPath,以防止 block 运行前的数据变动。 然后返回一个 block，其返回值必须为 ASCellNode。 没有必要担心Cell的复用以及初始化一个Cell的方法。您可能会注意到您现在返回了CardNode，而不是CardCell。 这让我想到一个重要的点。或许你已经了解到，使用 ASDK 不需要复用 cell，好吧，我已经说了两遍了，但能记住就好。请随意删除顶部kCellReuseIdentifier的定义吧 1static NSString *kCellReuseIdentifier = @\"CellReuseIdentifier\"; 你不必再担心 -prepareForReuse了 遵循 ASTableDelegate在 AnimalTableController.m 顶部，找到以下Delegate类别接口声明： 12@interface AnimalTableController (Delegate)&lt;UITableViewDelegate&gt;@end 用 ASTableDelegate 替换 UITableViewDelegate： 12@interface AnimalTableController (Delegate)&lt;ASTableDelegate&gt;@end 现在 AnimalTableController 已经遵循了 ASTableDelegate，是时候做处理了。在 AnimalTableController.m 底部找到 Delegate 分类的实现。 我们都知道，每个 UITableView 至少都要提供一个 -tableView:heightForRowAtIndexPath: 实现方法，因为每个 cell 的高度都由代理计算和返回。 ASTableDelegate 中没有 -tableView:heightForRowAtIndexPath:。再 ASDK 中，所有的 ASCellNode 都负责确定自己的大小。你可以选择为单元格定义最小和最大尺寸，而不是提供静态高度。这种情况下，你希望每个cell的高度至少为屏幕的 2／3。 现在不用担心太多，这个会在第二部分中介绍。 现在只需要替换 -tableView:heightForRowAtIndexPath:为: 1234567- (ASSizeRange)tableView:(ASTableView *)tableNode constrainedSizeForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat width = [UIScreen mainScreen].bounds.size.width; CGSize min = CGSizeMake(width, ([UIScreen mainScreen].bounds.size.height/3) * 2); CGSize max = CGSizeMake(width, INFINITY); return ASSizeRangeMake(min, max);&#125; 经过我们的辛勤劳动，重新编译、运行项目，看看发生了什么。 真是一个流畅的 tableView！一旦你开始做了，那就让我们做的更好吧！ 无限滚动在大多数应用中，服务器的数据点的个数往往会多于当前 tableView 中显示的单元格数量。这意味着，你必须通过某些手段做无缝处理，以便用户刷完当前数据列表时从服务端加载新的数据。 很多时候，这是通过手动观察滚动视图方法中的内容偏移来处理 scrollViewDidScroll:, 使用 ASDK， 有一种更具说明性的处理方式。相反的，你可以预先确定好你需要加载的页数。 你要做的第一件事是取消已经存在的方法的注释。在 AnimalTableController.m 的结尾，取消 Helpers 分类中的两个方法。你可以认为 -retrieveNextPageWithCompletion: 是你的网络调用，而 -insertNewRowsInTableNode: 是个非常典型的再表中添加新的元素的方法。 接下来，在 -viewDidLoad 添加： 1self.tableNode.view.leadingScreensForBatching = 1.0; // overriding default of 2.0 设置 leadingScreensForBatching 为 1.0 意味着当用户滑动一个屏的时候，就会载入新的数据。 继续，在 Delegate 分类中实现： 123- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123; return YES;&#125; 该方法用于告诉 tableView 是否继续请求新的数据。如果返回 NO，则在到达 API 数据末尾时，不会再不会发出任何请求。 因为你希望无限滚动，那就返回 YES，以确保总是请求新的数据。 接下来，还要添加： 123456789- (void)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context &#123; //1 [self retrieveNextPageWithCompletion:^(NSArray *animals) &#123; //2 [self insertNewRowsInTableNode:animals]; //3 [context completeBatchFetching:YES]; &#125;];&#125; 该方法在用户滑动到 table 的末端并，且 -shouldBatchFetchForTableNode: 方法返回 YES 时被调用。 让我们回顾下上面的章节： 首先，你要请求新的 animals 数据来展示。通常是通过 API 来获取的一组array。 完成后，用新下载的数据更新 tableView 最后，确保 -completeBatchFetching:返回的是YES，即大功告成。在完成操作之前，不会进行新的数据请求。 Build and Run，并且不停的滚呀滚。你将会看到不停的看到一只鸟，他们是无限的。 智能预加载你在工作中是否曾经遇到需要预先加载内容到 scrollView 或者 pageView 控制器中？也许你正在处理一个充满屏幕 image ，并且总是希望在接下来的几张图片加载时处于等待状态，所以用户很少看到占位符。 当你再这样的体系下工作时，你很快就会意识到有很多问题要考虑。 你占用了多少内存 你应该提前多久加载内容 你决定什么时候忽略用户的交互反映 并且当你考虑到多个维度的内容时，将些问题将会变得更加复杂。假设你有一个pageViewController，里面每个 viewController 都带有一个 collectionView。现在，你就需要考虑如何在两个方向上动态加载内容。同时，还要对每个设备进行优化。 还记得告诉你 ASRangeController 是不重要的吗？现在，这将是我们的重点。 在每个容器类中，所有包含的 node 都有一个接口状态的概念。在任何给定的时间，一个 node 可以是下面的任意组合： Preload Range（预载范围）：通常最远的范围从可见区域。这是当cell的每个 subNode （例如ASNetworkImageNode） 的内容从外源加载，例如API和本地缓存。这与批量获取时，使用用模型对象代表cell本身形成对比。 Display Range（显示范围）：在这里进行显示任务，例如文本绘制和进行图像解码。 Visible Range（可见范围）：此时，node 至少有一个像素在屏幕上。 这些范围也适用于 screenfuls 的度量，并且可以使用 ASRangeTuningParameters 属性轻松调整。 例如：你正在使用一个 ASNetworkImageNode在 gallery 的每个页面中展示图像，当每个cell进入 Preload Range 时，会发送网络请求，并且在进入 Display Range 时进行图像解码。 通常来说，你不必对这些 Ranges 太较真。利用好已有的组件，如：ASNetworkImageNode 和 ASTextNode，通常来说你将会获得极大的便利。 注意: 有件不明显的事，这些 Ranges 不是堆栈的。相反，它们会在Visible Range 上重叠和汇聚。如果将显示和预取都设置为一个屏幕，则它们将完全相同。通常数据需要存在才能显示，所以一般预取范围应该稍大一点。那么在 node 到达该范围时，就可以开始显示。 通常，该范围的前侧大于后侧。当用户改变其滚动方向时，范围的大小也是相反的，以便于对应用户实际移动的方向。 Node接口的状态回调你可能会疑惑：这些 Ranges 是如何正确工作的？很高兴你这样问~ 系统中的每个 node 都有一个interfaceState 属性，是一个带有字段（(NS_OPTION）ASInterfaceState类型。ASRangeController 负责管理 ASCellNode 在 scrolView 上的移动，每个subNode 都由一个 interfaceState 属性做对应的更新。这意味着即使时 tree 中最深的 nodes 也可以相应 interfaceState 的变化。 幸运的是，我们很少需要直接去操作 node 的 interfaceState 上的 二进制位。更常见的做法时，你只需要对某 node 的特定的状态进行更改。这就是接口的状态回调。 Node 命名为了看到一个 node 的各种状态，给它命名时很有必要的。这样，你就可以监测每个 node 的数据加载、内容成、屏幕展示以及所以的事情。 回到代码-tableNode:nodeBlockForRowAtIndexPath:,添加一句注释 //You&apos;ll add something extra here later... 在它的下面，给 cardNode 添加一个 debugName： 1cardNode.debugName = [NSString stringWithFormat:@\"cell %zd\", indexPath.row]; 观察 Cells进入 CardNode_InterfaceCallbacks.m 中，你可以找到六种追踪 node 在 ranges 中的状态的方法。取消注释，Build and Run。打开你的控制台，然后慢慢滑动 table。对照你的滑动，观察cell在对应的状态变化。 注意： 大多数情况下，你只要关心 -didEnterVisibleState 或 -didExitVisibleState 方法对 ASInterfaceState 的改变。或者说，已经为你做好了许多引擎。你可以查看 ASNetworkImageNode 中的代码，看看你集成的通过Preload 和 Display 状态实现的功能。 所有 node 网络图片的请求和解码，以及内存的释放都是自动完成，不费吹灰之力。 智能预加载（续）在 2.0 版本中，已经介绍了多个维度上智能与加载的概念。假设你有一个竖直滚动的tableView，在其中某些Cell包含了水平滚动的 collectionView。 尽管现在的技术能够实现，但你不会希望在到达可见区域之前预先加载全部的 collection。相反的，两个方向上的 scrollView 都由各自的 ASRangeController 单独控制自己的 range 参数。 来到二次元现在，你已经有了完整的 AnimalTableController， 你可以把它做为 ASPagerNode 的一个page。 项目已经提前写好了控制器的代码，首先进入 AppDelegate.m。 找到 -installRootViewController 的下面代码： 12AnimalTableController *vc = [[AnimalTableController alloc] initWithAnimals:[RainforestCardInfo allAnimals]]; 替换为： 1AnimalPagerController *vc = [[AnimalPagerController alloc] init]; 然后，跳到 AnimalPagerController.m 在 -init 方法中添加创建 pager 方法以及 dataSource 的数据源： 12_pagerNode = [[ASPagerNode alloc] init];_pagerNode.dataSource = self; pagerNode 是 ASCollectionNode 的子类，使用方法与 UIPageViewController 一样。API 实际上比 UIPageViewController 要简单的多。 接下来要实现 pager 的 dataSource 方法，在底部找到 ASPagerDataSource 分类. 首先，告诉 pager 有几个页面。实际上当前的 animal 数组中有三组不同动物，我们需要重写 -numberOfPagesInPagerNode:方法： 123- (NSInteger)numberOfPagesInPagerNode:(ASPagerNode *)pagerNode &#123; return self.animals.count;&#125; 然后，你需要实现 -pagerNode:nodeAtIndex 方法，类似于先前实现的 ASTableNode 的 dataSource 方法。 12345678910- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index &#123; // 1 NSArray *animals = self.animals[index]; // 2 ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^UIViewController * _Nonnull&#123; return [[AnimalTableController alloc] initWithAnimals:animals]; &#125; didLoadBlock:nil]; return node;&#125; 我们来总结下这部分： 尽管这个版本中没有进行模块化分，但是首先获取数据模型是个好习惯。 这一次，你使用的正是强大的 -initWithViewControllerBlock: 构造器。你所要做的就是返回一个block，这个 block 返回你提前设置好的 tableNodeController，它将自动展示在pager 的 页面中。真是太酷了😏~ 一旦你添加了这个方法，你将拥有一个完整功能的 Pagar，其中的 cell 是从你原先创建的 tableNodeController 生成的。现在，就可以在用户的垂直和水平滑动下，充分发挥二维预加载的功能！ 要查看这个 AsyncDisplayKit 2.0 教程完整的项目，点击这里进行下载。如果你想查看swift版本，这里也有。 准备好之后，请转到该项目的第2部分，了解 AsyncDisplayKit 2.0 引入的强大的新的布局系统。 如果你想先进行深入了解，你可以阅读 AsyncDisplayKit主页 的文档。Scott Goodson（AsyncDisplayKit的原创作者）也有几个你可能会感兴趣的话题。最近的话题很好的概述了一些框架对处理大图片存在问题的的尝试。 你可能会对 Paper的构建 感兴趣。虽然当时并没有开源，并且有许多地方发生了变化，但看到这一切的开始还是挺有意思的。 这里有一个 public Skack channel ,欢迎来提问~ 著作权声明本文译自 AsyncDisplayKit 2.0 Tutorial: Getting Started . 由@柏荧(BY)进行翻译,首次发布于 BY Blog，转载请保留原文链接.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://mysticpg.com/tags/Objective-C/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://mysticpg.com/tags/AsyncDisplayKit/"},{"name":"开源库","slug":"开源库","permalink":"http://mysticpg.com/tags/开源库/"}]},{"title":"","slug":"2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录","date":"2017-03-16T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/17/2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录/","link":"","permalink":"http://mysticpg.com/2017/03/17/2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录/","excerpt":"","text":"前言 最近在喵神 onevcat 的直播中发现喵神直接在终端就能用 vsCode 打开当前代码目录，非常方便。 在zsh终端中 使用 code .，在 vcCode 打开当前文件目录 正文配置终端环境终端环境为：iTerm2 + zsh) zsh 使用 oh_my_zsh 配置 安装zsh查看你的系统有几种shellcat /etc/shells 显示 /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 安装 oh my zshgit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 重新打开终端，输入 zsh 即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了 修改主题open ~/.zshrc 修改 ZSH_THEME=”robbyrussell”，主题在 ~/.oh-my-zsh/themes 目录下。修改为 ZSH_THEME=&quot;kolo&quot; 可以参照这里进行选择. 设置为默认shellchsh -s /bin/zsh 修改 zsh 配置文件$ open ~/.zshrc 在文件中加上这几行代码 对应 atom、SublimeText、与 vcCode。 alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos; alias subl=&apos;/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl&apos; alias code=&apos;/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code&apos; 测试使用 vcCode 打开 $ code . 本文首次发布于 BY Blog, 作者 @柏荧(BY) ,转载请保留原文链接.","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mysticpg.com/tags/Mac/"},{"name":"效率","slug":"效率","permalink":"http://mysticpg.com/tags/效率/"},{"name":"终端","slug":"终端","permalink":"http://mysticpg.com/tags/终端/"},{"name":"zsh","slug":"zsh","permalink":"http://mysticpg.com/tags/zsh/"}]},{"title":"CocoaPods私有仓库的创建","slug":"2017-03-10-CocoaPods私有仓库的创建","date":"2017-03-09T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/10/2017-03-10-CocoaPods私有仓库的创建/","link":"","permalink":"http://mysticpg.com/2017/03/10/2017-03-10-CocoaPods私有仓库的创建/","excerpt":"","text":"本文发布于 BY Blog、简书 转载请保留链接 上一篇文章 《CocoaPods公有仓库的创建》 前言最近参照了网上一大堆 CocoaPods私有仓库 的教程，按教程操作得到的pod仓库里面是这样的~ 代码和版本描述居然混在了一起，简直太糟糕~ 虽然也能用，但是和CocoaPods本身的结构设计就不相符。 在上一篇《CocoaPods公有仓库的创建》中我们了解到，master 目录中只存放 代码库 的描述文件，而不是存放代码。就像这样 代码我们另外存放在代码仓库中 很多人不了解CocoaPods的工作原理就复制粘贴别人的教程来做教程~ 吐槽结束，进入正文 正文创建版本库(repo)首先，创建一个像 master 一样的存放版本描述文件的git仓库，因为是私人git仓库，我们选择 oschina 创建远程私有仓库（因为是免费的）或者也可以在GitHub上创建（$7/month）。 下面以 oschina 为例 创建版本描述仓库 回到终端，将这个远程的私有版本仓库添加到本地，repo 就是 repository 储存库的缩写。 $ pod repo add MyRepo https://git.oschina.net/baiyingqiu/MyRepo.git 查看在 Finder 目录 ~/.cocoapods/repos， 可以发现增加了一个 MyRepo 的储存库 创建代码库回到 oschina 创建私人代码库 创建时添加 MIT License 和 README 将仓库克隆到本地，添加你的代码文件、仓库名.podspec 描述文件，还有.swift-version. 如下 .swift-version文件用来知道swift版本，用命令行创建 $ echo &quot;3.0&quot; &gt; .swift-version .podspec 文件是你这个代码库的pod描述文件,可以通过pod指令创建空白模板： $ pod spec create MyAdditions 或者 强烈建议 直接拷贝下面的模板进行修改 12345678910111213141516171819Pod::Spec.new do |s| s.name = \"MyAdditions\" # 项目名称 s.version = \"0.0.1\" # 版本号 与 你仓库的 标签号 对应 s.license = \"MIT\" # 开源证书 s.summary = \"私人pod代码\" # 项目简介 s.homepage = \"https://git.oschina.net/baiyingqiu/MyAdditions\" # 仓库的主页 s.source = &#123; :git =&gt; \"https://git.oschina.net/baiyingqiu/MyAdditions.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125;#你的仓库地址，不能用SSH地址 s.source_files = \"MyAdditions/*.&#123;h,m&#125;\" # 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件 s.requires_arc = true # 是否启用ARC s.platform = :ios, \"7.0\" #平台及支持的最低版本 # s.frameworks = \"UIKit\", \"Foundation\" #支持的框架 # s.dependency = \"AFNetworking\" # 依赖库 # User s.author = &#123; \"BY\" =&gt; \"qiubaiyingios@163.com\" &#125; # 作者信息 s.social_media_url = \"http://qiubaiying.github.io\" # 个人主页end 这里我要说一下一个坑，用 oschina 创建私人仓库时, 在验证时可能会找不到 MIT LICENSE证书,将其中的 s.license = &quot;MIT&quot; 修改为，指定文件 s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; } 然后开始验证我们的仓库配置是否正确，并按照要求进行修改 $ pod lib lint 一般出现错误警告，需要添加 --private 或者 --allow-warnings，就可以通过验证 $ pod lib lint --private 验证成功后出现 -&gt; MyAdditions (0.0.1) MyAdditions passed validation. 将描述文件推送到版本库将项目打上标签推到远程仓库，标签号 和 版本号对应 都是0.0.1 最后将我们的代码仓库的描述信息，push 到我们的版本仓库中 $ pod repo push MyRepo MyAdditions.podspec 这时会对远程仓库进行验证，成功的话就会在 ~/.cocoapods/repos/MyRep中发现新增的仓库描述信息了 若是出现错误信息 [!] The repo `MyRepo` at `../.cocoapods/repos/MyRepo` is not clean 更新下我们的版本库， $ pod repo update MyRepo 再继续上传即可。 pod repo push MyRepo MyAdditions.podspec 的过程就是 验证 MyAdditions.podspec 文件 拉取远程版本库 MyRepo 添加 MyAdditions.podspec 到版本库中 push 到远程 添加完成后我们就可以在pod中搜索 $ pod search MyAdditions -&gt; MyAdditions (0.0.1) Some category of the framework and UIKit pod &apos;MyAdditions&apos;, &apos;~&gt; 0.0.1&apos; - Homepage: https://git.oschina.net/baiyingqiu/MyAdditions - Source: https://git.oschina.net/baiyingqiu/MyAdditions.git - Versions: 0.0.1 [MyRepo repo] (END) 私人pod库的使用使用私人pod库的需要在Podflie中添加这句话，指明你的版本库地址。 source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’ 注意是版本库的地址，而不是代码库的地址，很多教程都把我搞晕了~ 若有还使用了公有的pod库，需要把公有库地址也带上 source ‘https://github.com/CocoaPods/Specs.git’ 最后的Podflie文件变成这个样子 source ‘https://github.com/CocoaPods/Specs.git’ source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’ platform :ios, &apos;8.0&apos; target ‘MyPodTest’ do use_frameworks! pod “BYPhoneNumTF” #公有库 pod ‘MyAdditions’ #我们的私有库 pod ‘BYAdditions’ #这是我又添加到版本库中的另一个代码库 end 测试： $ pod install 加载完成可以看到代码已经整合到我们的项目中了 perfect！ 回到Fender中 ~/.cocoapods/repos,会发现 repos 中增加了一个pod版本库。 执行 pod install 命令时 会拉取远程 Podflie 中 source 标记 版本库 到本地的 repos 文件夹中 在 版本库 中搜索我们pod ‘MyAdditions’ 的 MyAdditions.podspec 文件。 根据 MyAdditions.podspec 文件中描述的源码地址下载并整合到项目中 结语通过 《CocoaPods私有仓库的创建》 和 《CocoaPods公有仓库的创建》这两篇文章，相信大家对CocoaPods的工作原理都有了更深层次的了解。 在写博客和和创建的过程中，踩了不少的坑（😀前人教程留下的），很多的东西只有自己操作完才能真正的领会。 最后，如果本文有什么错误或者有什么不同的观点欢迎提出交流。😉","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://mysticpg.com/tags/CocoaPods/"},{"name":"Git","slug":"Git","permalink":"http://mysticpg.com/tags/Git/"}]},{"title":"CocoaPods公有仓库的创建","slug":"2017-03-08-CocoaPods公有仓库的创建","date":"2017-03-07T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/08/2017-03-08-CocoaPods公有仓库的创建/","link":"","permalink":"http://mysticpg.com/2017/03/08/2017-03-08-CocoaPods公有仓库的创建/","excerpt":"","text":"本文发布于 BY Blog、简书 转载请保留链接 前言作为iOS开发者，CocoaPods的使用为我们开发带来了极大的便利。 我们先来看看CocoaPods本地目录中有什么 $ cd ~/.cocoapods/repos/master 或者显示隐藏文件 $ defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 然后进入 ~/.cocoapods/repos/master 你会发现 master 是一个 git 仓库，输出仓库的远程地址，发现是一个GitHub仓库 $ git remote -v origin https://github.com/CocoaPods/Specs.git (fetch) origin https://github.com/CocoaPods/Specs.git (push) 继续，我们进入Specs文件夹一直往里点 你会发现很多框架以及版本号，选择一个框架，通过 $ pod search YYImage pod搜索 Specs 文件夹中的框架，输出框架信息 -&gt; YYImage (1.0.4) Image framework for iOS to display/encode/decode animated WebP, APNG, GIF, and more. pod &apos;YYImage&apos;, &apos;~&gt; 1.0.4&apos; - Homepage: https://github.com/ibireme/YYImage - Source: https://github.com/ibireme/YYImage.git - Versions: 1.0.4, 1.0.3, 1.0.2, 1.0.1, 1.0, 0.9.5, 0.9.4, 0.9.3, 0.9.2, 0.9.1, 0.9.0, 0.8.9 [master repo] - Subspecs: - YYImage/Core (1.0.4) - YYImage/WebP (1.0.4) 每个版本号对应的一个json文件,描述了每个对应版本的框架的信息、配置、及源码下载地。 我们在 CocoaPods 发布我们的框架时，就是要在 master 仓库中添加我们的仓库描述信息，然后push到远程仓库中。不过这个过程不用我们手动去操作，只需要通过pod命令进行操作即可。 下面我们将一步步把我封装的这个简单的TextFiled控件 BYPhoneNumTF 上传到 Cocoapods 公有仓库中。 正文注册 CocoaPods 账号想创建开源的Pod库，就要注册一个CocoaPods账号，我们使用终端注册, email 用你的 GitHub 邮箱 $ pod trunk register GitHub_email &apos;user_name&apos; --verbose 等终端出现下面文字，CocoaPods 会发一个确认邮件到你的邮箱上，登录你的邮箱进行确认。 [!] Please verify the session by clicking the link in the verification email that has been sent to you_email@163.com 注册成功！ 确认后再终端输入 pod trunk me 可以看到你的注册信息 创建Git仓库在 GitHub 上创建一个公开项目，项目中必须包含这几个文件 LICENSE:开源许可证 README.md:仓库说明 你的代码 BYPhoneNumTF.podspec: CocoaPods 的描述文件，这个文件非常重要 如下图： BYPhoneNumTF 文件夹下是我存放代码的地方 BYPhoneNumTF_Demo 是代码使用样例（不是必须的） 创建.podspec.podspec 是用 Ruby 的配置文件，描述你项目的信息。 在你的仓库目录下，使用终端命令创建 $ pod spec create BYPhoneNumTF 这时就会在你的仓库下生成 BYPhoneNumTF.podspec 文件 修改里面的配置就可以发布了~当然，没这么简单。 配置文件中的注释很多，而且很多配置都不是必须的，写多了等下验证还不让过~ so~强烈建议，直接拷贝下面的主要配置进行修改 12345678910111213141516171819Pod::Spec.new do |s| s.name = \"BYPhoneNumTF\" # 项目名称 s.version = \"1.0.0\" # 版本号 与 你仓库的 标签号 对应 s.license = \"MIT\" # 开源证书 s.summary = \"A delightful TextField of PhoneNumber\" # 项目简介 s.homepage = \"https://github.com/qiubaiying/BYPhoneNumTF\" # 你的主页 s.source = &#123; :git =&gt; \"https://github.com/qiubaiying/BYPhoneNumTF.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125;#你的仓库地址，不能用SSH地址 s.source_files = \"BYPhoneNumTF/*.&#123;h,m&#125;\" # 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件 s.requires_arc = true # 是否启用ARC s.platform = :ios, \"7.0\" #平台及支持的最低版本 s.frameworks = \"UIKit\", \"Foundation\" #支持的框架 # s.dependency = \"AFNetworking\" # 依赖库 # User s.author = &#123; \"BY\" =&gt; \"qiubaiyingios@163.com\" &#125; # 作者信息 s.social_media_url = \"http://qiubaiying.github.io\" # 个人主页end 最最关键的步骤的到了，验证 .podspec 文件的格式是否正确， $ pod lib lint 验证会出现成功出现 -&gt; BYPhoneNumTF (1.0.0) BYPhoneNumTF passed validation. 但是很多情况没这么顺利，比如: -&gt; BYPhoneNumTF (1.0.0) - WARN | url: There was a problem validating the URL http://qiubaiying.github.io. [!] BYPhoneNumTF did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it) and all results apply only to public specs, but you can use `--private` to ignore them if linting the specification for a private pod. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. You can use the `--no-clean` option to inspect any issue. 提示我们需要加--allow-warnings这么一句话，命令改为 $ pod lib lint --allow-warnings 若还是提示什么&#39;echo &quot;2.3&quot; &gt; .swift-version&#39;的，就加这么一个东西。 $ echo &quot;2.3&quot; &gt; .swift-version 然后在进行验证，这是应该就可以了。若还是不行，回到配置文件中检查有没有写错配置信息~ 给仓库打标签验证成功后，将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。 标签相当于将你的仓库的一个压缩包，用于稳定存储当前版本。标签号与你在 s.version = &quot;1.0.0&quot;的版本号一致 1.0.0 创建标签 $ git tag -a 1.0.0 -m &apos;标签说明&apos; 推送到远程 $ git push origin --tags 发布.podspec最后一步，发布项目的描述的文件 BYPhoneNumTF.podspec 在仓库目录下执行 pod trunk push BYPhoneNumTF.podspec 将你的 BYPhoneNumTF.podspec 发布到公有的speecs上,这一步其实做了很多操作,包括 更新本地 pods 库 ~/.cocoaPods.repo/master 验证.podspec格式是否正确 将 .podspec 文件转成 JSON 格式 对 master 仓库 进行合并、提交.master仓库地址 成功后将会出现下列信息： Updating spec repo `master` Validating podspec -&gt; BYPhoneNumTF (1.0.0) Updating spec repo `master` -------------------------------------------------------------------------------- 🎉 Congrats 🚀 BYPhoneNumTF (1.0.0) successfully published 📅 March 7th, 01:39 🌎 https://cocoapods.org/pods/BYPhoneNumTF 👍 Tell your friends! 说明发布成功，你就可以通过上面的URL: https://cocoapods.org/pods/BYPhoneNumTF 进入的Pods查看自己的仓库信息了. 使用仓库发布到Cocoapods后，在终端更新本地pods仓库信息 $ pod setup 查询仓库 $ pod search BYPhoneNumTF -&gt; BYPhoneNumTF (1.0.0) A delightful TextField of PhoneNumber pod &apos;BYPhoneNumTF&apos;, &apos;~&gt; 1.0.0&apos; - Homepage: https://github.com/qiubaiying/BYPhoneNumTF - Source: https://github.com/qiubaiying/BYPhoneNumTF.git - Versions: 1.0.0, 0.0.1 [BYPhoneNumTF repo] (END) 若出现仓库信息说明已经成功了，这时候你就可以在 Podfile 添加、使用自己的仓库了 pod &#39;BYPhoneNumTF&#39;, &#39;~&gt; 1.0.0&#39; 更新维护当你的代码更新维护后，就需要重写发布，流程是： 更新BYPhoneNumTF.podspec中的版本号 打上标签推送远程 pod trunk push BYPhoneNumTF.podspec 推送到pods仓库 更新后你就可以在 CocoaPods Master Repo 仓库上看到自己的提交记录了。 结语到此,你已经掌握了创建和维护一个Cocoapods公有仓库的技能了，是不是很棒~","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://mysticpg.com/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://mysticpg.com/tags/CocoaPods/"},{"name":"Git","slug":"Git","permalink":"http://mysticpg.com/tags/Git/"}]},{"title":"文件目录树状(tree)显示","slug":"2017-3-07-文件目录树状(tree)显示","date":"2017-03-06T16:00:00.000Z","updated":"2017-09-12T09:58:29.000Z","comments":true,"path":"2017/03/07/2017-3-07-文件目录树状(tree)显示/","link":"","permalink":"http://mysticpg.com/2017/03/07/2017-3-07-文件目录树状(tree)显示/","excerpt":"","text":"使用 tree 在终端显示树状文件结构 安装 tree使用 brew 进行安装 $ brew install tree 使用 直接使用 tree 命令，会在当前文件目录下，递归输出所有文件层级 $ tree 限制层级 $ tree -L 2 指定当前目录下的某个文件夹 $ tree Desktop 导出文件用&gt; 文件名.格式 的形式导出 $ tree -L 1 &gt; tree.md","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://mysticpg.com/tags/Mac/"},{"name":"效率","slug":"效率","permalink":"http://mysticpg.com/tags/效率/"},{"name":"开发技巧","slug":"开发技巧","permalink":"http://mysticpg.com/tags/开发技巧/"}]}]}